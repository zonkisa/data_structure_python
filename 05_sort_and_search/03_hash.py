# coding:utf-8
# 前面都是利用关于项在集合中相对于彼此存储的位置的信息
# 最初，哈希表不包含项，因此每个槽都为空。
# 可以通过使用列表来实现一个哈希表，每个元素初始化为None
# 项和该项在散列表中所属的槽之间的映射被称为 hash 函数
# hash 函数将接收集合中的任何项，并在槽名范围内（0和 m-1之间）返回一个整数。
# 假设有整数项 54,26,93,17,77 和 31 的集合。
# 第一个 hash 函数，有时被称为 余数法 ，只需要一个项并将其除以表大小，
# 返回剩余部分作为其散列值（h(item) = item％11）  哈希值
# 这种余数方法（模运算）通常以某种形式存在于所有散列函数中，因为结果必须在槽名的范围内
# 11 个插槽中的 6 个现在已被占用。
# 这被称为负载因子，通常表示为 λ=项数/表大小, 在这个例子中，λ = 6/11 。
# 当我们要搜索一个项时，我们只需使用哈希函数来计算项的槽名称，然后检查哈希表以查看它是否存在。
# 该搜索操作是 O(1)，因为需要恒定的时间量来计算散列值，
# 然后在该位置索引散列表。如果一切都正确的话，我们已经找到了一个恒定时间搜索算法。
# 根据散列函数，两个或更多项将需要在同一槽中。这种现象被称为碰撞

# 目标是创建一个散列函数，最大限度地减少冲突数，易于计算，并均匀分布在哈希表中的项。
# 有很多常用的方法来扩展简单余数法。我们将在这里介绍其中几个

# 分组求和法
# 将项划分为相等大小的块（最后一块可能不是相等大小）
# 然后将这些块加在一起以求出散列值。
# 例如，如果项是电话号码 436-555-4601，将取出数字，并将它们分成2位数（43,65,55,46,01）。
# 43 + 65 + 55 + 46 + 01，我们得到210
# 假设哈希表有11个槽，那么需要除以11
# 在这种情况下，210％11为1，因此电话号码436-555-4601散列到槽1
# 一些分组求和法也会在求和之前每隔一个反转。
# 对于上述示例，我们得到 43 + 56 + 55 + 64 + 01 = 219，其给出 219％11 = 10


# 用于构造散列函数的另一数值技术被称为 平方取中法。
# 我们首先对该项平方，然后提取一部分数字结果
# 例如，如果项是 44，我们将首先计算 44^2 = 1,936
# 通过提取中间两个数字93，我们得到5（93％11）

# 为基于字符的项（如字符串）创建哈希函数。词cat可以被认为是ascii值的序列
# 可以获取这三个ascii值，将它们相加，并使用余数方法获取散列值

def hash(astring, tablesize):
    sum = 0
    for pos in range(len(astring)):
        sum = sum + ord(astring[pos])

    return sum % tablesize


